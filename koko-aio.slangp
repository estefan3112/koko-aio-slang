# TODO:
#    [v] Guess more aspect ratios:
#			nope: Guessing is impossible..
#    [v] Use gauss blur for composite color bleeding?
#    	    Tried, does not produce great visible improvements
#    [ ] Vignette and spot could be done earlier at lower res?
#    [ ] check branching conditions in first_pass.slang
#    [v] reference new repo from the main one
#    [v] Noise is not visible on black or white, much more on gray, why?
#        Probably a matter of post processing
#    [ ] Try to get rid of mark_unneeded() in reflection_blur_y
#    [v] Why tv presets have +5% brightness?
#        Because the contrast is pushed too.


    
#    Koko-aio shader is meant to be an all-in one crt shader.
#    It can be configured with many parameters, so that can be
#    scaled to run on even on modest gpus while still developed to
#    run with heavier presets on at least Haswell+ iGpus.
#    It is not meant to simulate the internal behaviour of CRT displays,
#    but to give users the parameters to make their monitors to look similar.
#    Several presets are included.

#    Actually it provides emulation for:
#        scanlines, screenlines, RGB vertical masks, horizontal slot masks,
#        glowing, haloing, blooming, gamma and SATURATION correction,pixel_outi        
#        black frame insertions, interlace emulation, antialiasing.

#    External code by:
#    * CRT - Guest - Dr.Venom (single pass bloom function)
#    * Nvidia (FXAA)




    
# Bezel texture contains the following infomations:
#   - The red channel represents the luminance information
#   - The green channel represents the highlights
#   - The alpha channel in the inner frame represents the part of the bezel that will be filled by the game content
#   - The blue channel represents the part of the bezel that will be filled by the game reflection.


                textures = "monitor_body_curved;monitor_body_straight;bg_under;bg_over;backdrop"
                
            monitor_body_curved = "textures/monitor_body_curved.png"
     monitor_body_curved_linear = "true"
  # Does this work?
  monitor_body_curved_wrap_mode = "clamp_to_edge"
     monitor_body_curved_mipmap = "true"

            monitor_body_straight = "textures/monitor_body_straight.png"
     monitor_body_straight_linear = "true"
  # Does this work?
  monitor_body_straight_wrap_mode = "clamp_to_edge"
     monitor_body_straight_mipmap = "true"
     
                bg_under = "textures/background_under.png"
         bg_under_linear = "true"
      bg_under_wrap_mode = "mirrored_repeat"
         bg_under_mipmap = "true"
          
                 bg_over = "textures/background_over.png"
          bg_over_linear = "true"
       bg_over_wrap_mode = "mirrored_repeat"
          bg_over_mipmap = "true"

        #This is for support for arcade backdrop pictures, enable it in config.inc.
                backdrop = "textures/boothill.jpg"
         backdrop_linear = "true"
      backdrop_wrap_mode = "mirrored_repeat"
         backdrop_mipmap = "true"

shaders = 19
# For P-uae defaults, doubling just y0 seems the best option.
#  90% of games are lowres in vertical size and p-uae defaults
#  to 720 pixels width, which is enough for this preset to work as intended.
#  Rest warned, that when a game sets an interlaced resolution, p-uae
#  will output even 560 h-lines which, doubled, will result in
#  1120 h lines. too much even for a 1080p screen.
#  Auto-Cropping/overscan emulation could be added in a future release.
#  For other emulators/systems, probably it is best and safe to doulbe x0 too.

# In the first pass we draw an optional black border around the image for bezel purposes
#   and scale the image to something better usable by FXAA
#   Scaling y to 2x is needed by flickering scanlines pass.

           shader0 = shaders/ntsc_pass.slang
            alias0 = "ntsc_pass"
    filter_linear0 = false
       scale_type0 = source
            scale0 = 1.0
        wrap_mode0 = "mirrored_repeat"

           shader1 = shaders/first_pass.slang
            alias1 = "first_pass"
    filter_linear1 = false
       scale_type1 = source
            scale1 = 2.0
        wrap_mode1 = "mirrored_repeat"

# Nvidia fxaa pass:
#   works good for "SD" resolutions
           shader2 = shaders/fxaa.slang
            alias2 = "FXAA_pass"
    filter_linear2 = true
       scale_type2 = source
            scale2 = 1.0
            
#   FXAA don't really need any mipmap, but avglum_pass several passes after it does.
#   and for the weird way retroarch manages mipmaps, specify that FXAA_pass wants mipmaps
#   makes first_pass mipmaps available to everyone.
#   even if theoretically not needed, texture() occurrence in FXAA_pass needed to be switched 
#   to textureLod(..,0.0) or it acts weird, don't ask me why.
#   yay.

     mipmap_input2 = true
        wrap_mode2 = "mirrored_repeat"

# This pass emulates composite color bleeding and deconvergence
# deconvergence should be applied in th final pass, but it is too heavy there.
# This pass also apply the input gamma needed for halo or glow.
           shader3 = shaders/shift_and_bleed.slang
            alias3 = "shift_and_bleed_pass"
    filter_linear3 = true
            scale3 = 1.0
       scale_type3 = source
float_framebuffer3 = true
     mipmap_input3 = false
        wrap_mode3 = "mirrored_repeat"



# Blur and glow the image as requested 
#   This pass aims to simulate the signal input power.
#   Glowing will be used to weighting the scanlines.
#   In this pass we also generate flickering scanlines by blindly blanking
#   alternate lines at #frame interval

           shader4 = shaders/in_glow_x.slang
            alias4 = "in_glow_pass_x"
    filter_linear4 = true
            scale4 = 1.0
       scale_type4 = source    
float_framebuffer4 = true
        wrap_mode4 = "mirrored_repeat"
        
           shader5 = shaders/in_glow_y.slang
            alias5 = "in_glow_pass"
    filter_linear5 = true
            scale5 = 1.0
       scale_type5 = source    
float_framebuffer5 = true
        wrap_mode5 = "mirrored_repeat"
            
          
# This essentially is the same as glowing by a code point of view.
#   But this pass will be added later on instead of mixed

           shader6 = shaders/halo_x.slang
            alias6 = "halo_pass_x"
    filter_linear6 = true
            scale6 = 1.0
       scale_type6 = source
float_framebuffer6 = true
     mipmap_input6 = false
        wrap_mode6 = "mirrored_repeat"
        
           shader7 = shaders/halo_y.slang
            alias7 = "halo_pass"
    filter_linear7 = true
            scale7 = 1.0
       scale_type7 = source
float_framebuffer7 = true
     mipmap_input7 = false
        wrap_mode7 = "mirrored_repeat"
        
# Get the average luminance needed by ambilight here, because:
#   * mipmap_input only works on "Source" texture
#   * the following pass does not use the previous one 
#   * the previous pass represents scene changes.

#   The rgb channels of the following pass contains luminance info
#   Used by the bezel code to light up the bezel corners.
#   The alpha channel contains the sum/3.0 of rgb channels
#   used to detect scene changes.

               shader8 = shaders/avglum_pass.slang
                alias8 = "avglum_pass"
        filter_linear8 = true
           scale_type8 = source
                scale8 = 0.5
            wrap_mode8 = "mirrored_repeat"
         mipmap_input8 = false

# The following 2 passes will blur the mirrored part of main pass
#   to emulate bezel reflections.
   
               shader9 = shaders/reflection_blur_x.slang
                alias9 = "reflected_blurred_pass1"
        filter_linear9 = true
           scale_type9 = source
                scale9 = 1.0
            wrap_mode9 = "mirrored_repeat"

               shader10 = shaders/reflection_blur_y.slang
                alias10 = "reflected_blurred_pass2"
        filter_linear10 = true
           scale_type10 = source
                scale10 = 1.0
            wrap_mode10 = "mirrored_repeat"


# In the subsequent passes we do first a fast bloom  by first
#   sampling the original texture and scale it down to keep
#   it fast, next we do subsequent blurd of the bloomed
#   pass.
   
               shader11 = shaders/bloom_pass_1.slang
                alias11 = "bloom_pass_1"
        filter_linear11 = true
           scale_type11 = source
                scale11 = 1.0
# I NEED TO SET **THIS** TO mirrored_repeat TO HAVE THE PREVIOUS PASS mirrored_repeated (!?)
            wrap_mode11 = "mirrored_repeat"
    
    
               shader12 = shaders/bloom_pass_2.slang
                alias12 = "bloom_pass_2"
        filter_linear12 = true
           scale_type12 = source
                scale12 = 0.5
            wrap_mode12 = "clamp_to_edge"

            
               shader13 = shaders/bloom_pass_3.slang
                alias13 = "bloom_pass_3"
        filter_linear13 = true
           scale_type13 = source
                scale13 = 1.0
            wrap_mode13 = "clamp_to_edge"

        
               shader14 = shaders/bloom_pass_4.slang
                alias14 = "bloom_pass_final"
        filter_linear14 = true
           scale_type14 = source
                scale14 = 1.0
            wrap_mode14 = "mirrored_repeat"

        
# Back led lights:
# Since the next pass will need mipmaps of the original image, and is only possible to get mipmaps
# from the very previous pass, the next one will just passthrough the original image


               shader15 = shaders/ambi_push_pass.slang
                alias15 = "ambi_push_pass"
# I NEED TO SET **THIS** TO true TO HAVE THE PREVIOUS PASS linearly filtered
        filter_linear15 = true
           scale_type15 = source
                scale15 = 1.0
            wrap_mode15 = "mirrored_repeat"
         mipmap_input15 = false

# Gather mipmaps from prevous pass and use them to light virtual leds under the virtual monitor 
# and Temporally smooth led lights.
               shader16 = shaders/ambi_pre_pass.slang
                alias16 = "ambi_temporal_pass"
        filter_linear16 = true
           scale_type16 = source
                scale16 = 0.5
         mipmap_input16 = true
            wrap_mode16 = "clamp_to_border"
    float_framebuffer16 = true


# In this pass we gather information about the rotated state of the source
#   This information can only be taken when a pass scales to viewport
#   So use a low output resolution to keep things as light as possible.
#   The feedback of this pass will be queried by previous ones.
#   I tried to move this into final_pass, but the gpu consumption was higher.

           shader17 = shaders/isrotated.slang
            alias17 = "isrotated_pass"
    filter_linear17 = true
            scale17 = 0.1
       scale_type17 = viewport
        wrap_mode17 = "mirrored_repeat"   

# In this pass we emulate scanlines, glowing,
#   RGB vertical mask, slot mask,haloing and color corrections
        
# This pass pass will do the composition of the previous passes
#   with the bloomed image, vignette and spot light,  black frame insertions
#   and Bezel emulation

           shader18 = shaders/final_pass.slang
            alias18 = "final_pass"
    filter_linear18 = true
       scale_type18 = viewport
            scale18 = 1.0
        wrap_mode18 = "mirrored_repeat"

