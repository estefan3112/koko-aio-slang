/*TODO:
    Guess more aspect ratios: edit. nope: Guessing is pointless.
    Update presets with new switchable functions
    Update pipeline graph
    Investigate the possible use of mipmapping in bloom function too.
    optimize:
    vignette and spot (try with lower resolution)
    curvature (warp is really slow, try other algs, or put it before anything).
    also check if double scaling at beginning is really useful.
    mix vignette and spotlight in another pass or they will be used by ambilight.

    Base gpu (use% blitter + render) no shader: 7+6 = 13
    shader, no effects: 35+5 = 40
    shader + spot +vignette 40.8= 41
    curvature, warp only over y: 61
    curvature, only border: 41.68


*/

/*
    Koko-aio shader is meant to be an all-in one crt shader.
    It can be configured with many parameters, so that can be
    scaled to run on even on modest gpus while still developed to
    run with heavier presets on at least Haswell+ iGpus.
    It is not meant to simulate the internal behaviour of CRT displays,
    but to give users the parameters to make their monitors to look similar.
    Several presets are included.

    Actually it provides emulation for:
        scanlines, screenlines, RGB vertical masks, horizontal slot masks,
        glowing, haloing, blooming, gamma and saturation correction,
        black frame insertions, interlace emulation, antialiasing.

    External code by:
    * CRT - Guest - Dr.Venom (single pass bloom function)
    * Nvidia (FXAA)



* Pipeline *
------------

→ → Original image from emulator
     ↓
    Double the input size
     ↓
    FXAA antialiasing
     ↓
    Emulate scanlines → Input Glow → phosphors → slot mask/aperture grill →  halo →
                                                                                    ↓
                                                                                    ↓
→ → Original image from emulator                                                    ↓
     ↓                                                                              ↓
    Bloom                                                                           ↓
     ↓                                                                              ↓
    mix  ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ←
     ↓
    Color correction → Vignette, spot → Black frame insertion
                                                ↓
                                            Viewport


*/

shaders = 20
/*For P-uae defaults, doubling just y0 seems the best option.
  90% of games are lowres in vertical size and p-uae defaults
  to 720 pixels width, which is enough for this preset to work as intended.
  Rest warned, that when a game sets an interlaced resolution, p-uae
  will output even 560 h-lines which, doubled, will result in
  1120 h lines. too much even for a 1080p screen.
  Auto-Cropping/overscan emulation could be added in a future release.
  For other emulators/systems, probably it is best and safe to doulbe x0 too.
*/
    shader0 = shaders/passthrough.slang
    alias0 = "doublesize_pass"
    filter_linear0 = false
    scale_type0 = source
    scale_x0 = 2.0
    scale_y0 = 2.0

/* Nvidia fxaa pass:
   works good for "SD" resolutions
*/
    shader1 = shaders/fxaa.slang
    alias1 = "FXAA_pass"
    filter_linear1 = true
    scale_type1 = source
    scale1 = 1.0

    //this as a "pass" is somehow important for the main pass to work good.
    //also, there it will do flickering scanlines.
    shader2 = shaders/scanline-flickering.slang
    scale_type2 = source
    filter_linear2 = true
    scale2 = 1.0


/* In this pass we emulate scanlines, glowing,
   RGB vertical mask, slot mask,haloing and color corrections
*/
    shader3 = shaders/main_pass.slang
    alias3 = "main_pass"
    filter_linear3 = true
    scale3 = 1.0
    scale_type3 = viewport

/* In the subsequent passes we do first a fast blOOm by first
   sampling the original texture and scale it down to keep
   it fast, next we do subsequent blURs of the bloomed
   pass.
   */
        shader4 = shaders/passthrough_conditional_bloom.slang
        alias4 = "bloom_pass_0"
        filter_linear4 = true
        scale_type4 = absolute
        scale_x4 = 320
        scale_y4 = 240

        shader5 = shaders/bloom_pass_1.slang
        alias5 = "bloom_pass_1"
        filter_linear5 = true
        scale_type5 = source
        scale5 = 1

        shader6 = shaders/bloom_pass_2.slang
        alias6 = "bloom_pass_2"
        filter_linear6 = true
        scale_type6 = source
        scale6 = 1

        //shader6 = shaders/passthrough.slang
        shader7 = shaders/bloom_pass_2.slang
        alias7 = "bloom_pass_3"
        filter_linear7 = true
        scale_type7 = source
        scale7 = 1

        //shader8 = shaders/passthrough.slang
        shader8 = shaders/bloom_pass_2.slang
        alias8 = "bloom_pass_final"
        filter_linear8 = true
        scale_type8 = source
        scale8 = 1

// Draw vignette and spot on lower resolution
    shader9 = shaders/vignette.slang
    scale_type9 = absolute
    alias9 = vignette_pass
    filter_linear9 = true
    scale_x9 = 256
    scale_y9 = 256

    shader10 = shaders/spot.slang
    scale_type10 = absolute
    alias10 = spot_pass
    scale_x10 = 256
    scale_y10 = 256


/* This pass pass will do the composition of the previous passes
   with the bloomed image, vignette and spot light,  and black frame insertions.
*/
    shader11 = shaders/final_pass.slang
    alias11 = "final_pass"
    filter_linear11 = true
    scale_type11 = viewport
    scale11 = 1.0

/* Create the ambilight magic: */

        shader12 = shaders/passthrough_conditional_ambi.slang
        filter_linear12 = true
        scale_type12 = source

        //...then just downscale via mipmapping here:
        shader13 = shaders/passthrough_conditional_ambi.slang
        alias13 = "ambi_downscale_pass"
        filter_linear13 = true
        scale_type13 = absolute
        scale_x13 = 32
        scale_y13 = 32
        mipmap_input13 = true

        shader14 = shaders/ambi_pre_pass.slang
        alias14 = "ambi_pre_pass0"
        filter_linear14 = true
        scale_type14 = source

        shader15 = shaders/ambi_pre_pass.slang
        alias15 = "ambi_pre_pass1"
        filter_linear15 = true
        scale_type15 = source
        /*
          The following pass should really stay before the downscale (**),
          but unfortunately, maybe due to a bug in my system,
          moving it there produces weird graphical glitches
        */
        shader16 = shaders/ambi_avglum_pass.slang
        alias16 = "ambi_avglum_pass"
        filter_linear16 = false
        scale_type16 = source
        mipmap_input16 = true


        shader17 = shaders/ambi_temporal_pass.slang
        alias17 = "ambi_temporal_pass"
        filter_linear17 = true
        scale_type17 = source


        //shader14 = shaders/passthrough.slang
        //alias14 = "ambi_last_pass"
        //filter_linear14 = true
        //scale_type14 = viewport
        //scale13 = 1.0


    shader18 = shaders/curvature.slang
    alias18 = "curvature_pass"
    scale_type18 = viewport
    scale18 = 1.0
    filter_linear18 = true

    shader19 = shaders/ambi_mix_pass.slang
    alias19 = "ambientmix_pass"
    scale_type19 = viewport
    scale19 = 1.0
    filter_linear19 = true

