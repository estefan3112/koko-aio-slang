/*TODO:
    Guess more aspect ratios: edit. nope: Guessing is impossible..
    Update presets with new switchable functions
    Update pipeline graph

    Investigate the possible use of mipmapping in bloom function too.
    Try to move flickering scanlines into main, maybe by faking them with screenlines?
    Halo should take in_glow if available (?)
    
Performances:
haswell igp: i5-4590 CPU @ 3.30GHz
Ouutput on aspect: full, 1080p, 16:9, 60fps
input: mame, dynamite dux:
                    GPU%        Delta% vs Basal:
         no shader: 11          -23.6               
             basal: 34.6        0.0                31.2
              FXAA: 37.5        2.9                35
         scanlines: 36.5        1.9                32.3
     ...flickering: 36.2        1.6
input glow gamma 3: 40          5.4                36.5
          rgb mask: 35.7        1.1                
          slotmask: 36.5        1.9
      halo gamma 3: 40.0        5.4
          bloom,hq: 38-43       3.4-8.4            35-40
 color corrections: 35          0.4
    curvature warp: 39.2        4.6               33.5
     vignette+spot: 35.2        0.6               32.9  ++
     ambient light: 38          3.4               33.5
-----------------------------------------------
Total basal + all the features: 72.2            67.70
    
*/

/*
    Koko-aio shader is meant to be an all-in one crt shader.
    It can be configured with many parameters, so that can be
    scaled to run on even on modest gpus while still developed to
    run with heavier presets on at least Haswell+ iGpus.
    It is not meant to simulate the internal behaviour of CRT displays,
    but to give users the parameters to make their monitors to look similar.
    Several presets are included.

    Actually it provides emulation for:
        scanlines, screenlines, RGB vertical masks, horizontal slot masks,
        glowing, haloing, blooming, gamma and saturation correction,pixel_outi
        
        black frame insertions, interlace emulation, antialiasing.

    External code by:
    * CRT - Guest - Dr.Venom (single pass bloom function)
    * Nvidia (FXAA)



* Pipeline *
------------

→ → Original image from emulator
     ↓
    Double the input size
     ↓
    FXAA antialiasing
     ↓
    Emulate scanlines → Input Glow → phosphors → slot mask/aperture grill →  halo →
                                                                                    ↓
                                                                                    ↓
→ → Original image from emulator                                                    ↓
     ↓                                                                              ↓
    Bloom                                                                           ↓
     ↓                                                                              ↓
    mix  ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ← ←
     ↓
    Color correction → Vignette, spot → Black frame insertion
                                                ↓
                                            Viewport


*/


/* Bezel texture contains the following infomations:
   - The red channel represents the luminance information
   - The green channel represents the highlights
   - The alpha channel in the inner frame represents the part of the bezel
   that will be filled by the game content
   - The blue channel represents the part of the bezel that will be filled by the game reflection.
*/

                textures = "monitor_body"
            monitor_body = "textures/f1.png"
     monitor_body_linear = "true"
  monitor_body_wrap_mode = "clamp_to_edge" //Does this work?



shaders = 17
/*For P-uae defaults, doubling just y0 seems the best option.
  90% of games are lowres in vertical size and p-uae defaults
  to 720 pixels width, which is enough for this preset to work as intended.
  Rest warned, that when a game sets an interlaced resolution, p-uae
  will output even 560 h-lines which, doubled, will result in
  1120 h lines. too much even for a 1080p screen.
  Auto-Cropping/overscan emulation could be added in a future release.
  For other emulators/systems, probably it is best and safe to doulbe x0 too.
*/



           shader0 = shaders/passthrough.slang
            alias0 = "doublesize_pass"
    filter_linear0 = false
       scale_type0 = source
          scale_x0 = 2.0
          scale_y0 = 2.0
        wrap_mode0 = "clamp_to_edge"
/* Nvidia fxaa pass:
   works good for "SD" resolutions
*/
           shader1 = shaders/fxaa.slang
            alias1 = "FXAA_pass"
    filter_linear1 = true
       scale_type1 = source
            scale1 = 1.0
        wrap_mode1 = "mirrored_repeat"
        
    //Put in_glow in its own pass so that we can use lower resolution
           shader2 = shaders/in_glow_and_scanline_flickering.slang
            alias2 = "in_glow_and_scanline_flickering_pass"
    filter_linear2 = true
            scale2 = 1
       scale_type2 = source    
float_framebuffer2 = true
        wrap_mode2 = "mirrored_repeat"
            
          
    //Put halo in its own pass so that we can use lower resolution
           shader3 = shaders/halo.slang
            alias3 = "halo_pass"
    filter_linear3 = true
            scale3 = 1
       scale_type3 = source
float_framebuffer3 = true
        wrap_mode3 = "mirrored_repeat"

   //In this pass we gather information about the rotated state of the source
   //This information can only be taken when a pass scales to viewport
   //Use a low output resolution to keep things as light as possible.
           shader4 = shaders/isrotated.slang
            alias4 = "isrotated_pass"
    filter_linear4 = true
            scale4 = 0.1
       scale_type4 = viewport
        wrap_mode4 = "mirrored_repeat"   
        
/* In this pass we emulate scanlines, glowing,
   RGB vertical mask, slot mask,haloing and color corrections
*/
           shader5 = shaders/main_pass.slang
            alias5 = "main_pass"
    filter_linear5 = true
            scale5 = 1.0
       scale_type5 = viewport
        wrap_mode5 = "mirrored_repeat"
     
     
     
/*      Get the average luminance needed by ambilight here, because:
        * mipmap_input only works on "Source" texture
        * the following pass does not use the previous one 
        * the previous pass represents scene changes.
*/
         //The rgb channels of the following pass contains luminance info
         //Used by the bezel code to light up the bezel corners.
         //The alpha channel contains the sum/3.0 of rgb channels
         //used to detect scene changes.
               shader6 = shaders/avglum_pass.slang
                alias6 = "avglum_pass"
        filter_linear6 = true
           scale_type6 = absolute
              scale_x6 = 320
              scale_y6 = 240
            wrap_mode6 = "mirrored_repeat"
         mipmap_input6 = true
         
               shader7 = shaders/reflection_blur_h.slang
                alias7 = "reflected_blurred_pass1"
        filter_linear7 = true
           scale_type7 = source
                scale7 = 1.0
            wrap_mode7 = "mirrored_repeat"
//FIXME: mipmap_input here is probably useless
         mipmap_input7 = false
         
               shader8 = shaders/reflection_blur_v.slang
                alias8 = "reflected_blurred_pass2"
        filter_linear8 = true
           scale_type8 = source
                scale8 = 1.0
            wrap_mode8 = "mirrored_repeat"
            


/* In the subsequent passes we do first a fast blOOm by first
   sampling the original texture and scale it down to keep
   it fast, next we do subsequent blURs of the bloomed
   pass.
*/
        
               shader9 = shaders/bloom_pass_1.slang
                alias9 = "bloom_pass_1"
        filter_linear9 = true
           scale_type9 = absolute
              scale_x9 = 320
              scale_y9 = 240
            //WHY ON EARTH I NEED TO SET **THIS** TO MIRRORED REPEAT TO HAVE THE PREVIOUS PASS MIRRORED REPEAT!?!?!?
            wrap_mode9 = "mirrored_repeat" 
        
               shader10 = shaders/bloom_pass_2.slang
                alias10 = "bloom_pass_2"
        filter_linear10 = true
           scale_type10 = source
                scale10 = 1
            wrap_mode10 = "clamp_to_edge"
        
               shader11 = shaders/bloom_pass_2.slang
                alias11 = "bloom_pass_3"
        filter_linear11 = true
           scale_type11 = source
                scale11 = 1
            wrap_mode11 = "clamp_to_edge"
        
               shader12 = shaders/bloom_pass_2.slang
                alias12 = "bloom_pass_final"
        filter_linear12 = true
           scale_type12 = source
                scale12 = 1
            wrap_mode12 = "mirrored_repeat"
        
/* Create the ambilight magic: */
        //...repeat left and right borders
               shader13 = shaders/ambi_displace.slang
                alias13 = "ambi_displace_pass"
           scale_type13 = absolute
              scale_x13 = 320
              scale_y13 = 320
            wrap_mode13 = "mirrored_repeat"
         mipmap_input13 = false

        //...then just downscale via mipmapping here:
               shader14 = shaders/ambi_pre_pass.slang 
                alias14 = "ambi_pre_pass1"
        filter_linear14 = true
           scale_type14 = absolute
              scale_x14 = 320
              scale_y14 = 320
         mipmap_input14 = true
            wrap_mode14 = "clamp_to_border"


               shader15 = shaders/ambi_temporal_pass.slang
                alias15 = "ambi_temporal_pass"
        filter_linear15 = true
           scale_type15 = source
    float_framebuffer15 = true

    
/* This pass pass will do the composition of the previous passes
   with the bloomed image, vignette and spot light,  and black frame insertions.
*/
           shader16 = shaders/final_pass.slang
            alias16 = "final_pass"
    filter_linear16 = true
       scale_type16 = viewport
            scale16 = 1.0
        wrap_mode16 = "mirrored_repeat"

