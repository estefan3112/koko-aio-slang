#define alpha_mark 0.1
//content_x(y)_scale are the sizes of the viewport relative to the game content
float content_x_scale(){
    return params.OutputSize.x/(in_aspect * params.OutputSize.y);
}

float content_y_scale(){
    return 1.0;
}

float calc_offset_x(float uv_scale_x){
    return (0.5 * uv_scale_x ) - 0.5 ;
}

vec2 calc_uv() {
    vec2 uv_scale = vec2( content_x_scale() , content_y_scale() );
    vec2 uv ;
    uv.x = vTexCoord.x * uv_scale.x;
    uv.y = vTexCoord.y * uv_scale.y;

    float offset_x = calc_offset_x(uv_scale.x);
    uv.x = uv.x - offset_x ;

    return uv;
}

vec4 mark_outer_frame(vec3 pixel) {
    //For my mental sanity, I use a specific alpha channel value to mark a frame as a border
    return vec4(pixel.r,pixel.g,pixel.b,alpha_mark) ;
}

bool is_outer_frame(vec4 pixel) {
    /*Check if a pixel is marked as border by comparing the value of its alpha channel
      Tolerance is needed, because precision can be as low as 1/256; since I don't need
      alpha channel, use an even large tolerance.
    */
    return  abs(pixel.a - alpha_mark) < 0.05; //<-- 0.05 allow about 20 alpha levels (1*0.05)
}

/*bool coord_is_inside_frame(vec2 pixelcoord) {
    vec2 uv=calc_uv();
    float offset_x = calc_offset_x( content_x_scale() ) ; 
    if (pixelcoord.x > offset_x)
        if (pixelcoord.x < 1.0-offset_x)
            return true;
    return false; //giallo

}
*/


float get_in_aspect() {
    //320x224 -> 4:3

    if ( aspect_x == 0 ) {
        //Try to detect original aspect ratio (...)
        return 4./3. ; // FIXME: Stub

        float size_x = params.OriginalSize.x;
        float size_y = params.OriginalSize.y;
        //P-uae outputs something like 640x256 by default, but the aspect is not it, adapt:
        if ((size_x/size_y) > 1.8) size_x = size_x / 2.0;
        return size_x/size_y;
    }
    //else return user defined one
    return aspect_x/aspect_y;
}

vec2 get_scaled_coords(vec2 pTexCoord){
    if (DO_AMBILIGHT == 0) return pTexCoord;
        //else
    float scale_x = params.OutputSize.x/(get_in_aspect() * params.OutputSize.y);
    float scale_y = 1.0;
    float offset_x = (0.5 * scale_x ) - 0.5 ;
    vec2 scale_coord=vec2(pTexCoord.x*scale_x - offset_x,pTexCoord.y*scale_y);
    return scale_coord;
}
